# v1.21.0 (Minor Release)

**Status**: In progress

<!-- alex-c-line-start-release-summary -->
This is a new minor release of the `alex-c-line` package. It introduces new features in a backwards-compatible way and should require very little refactoring, if any. Please read the description of changes below.
<!-- alex-c-line-end-release-summary -->

## Description of Changes

- Adds a new (but experimental) `use-local-package` command.
    - This is helpful in cases where you want to use a locally saved version of a package you're developing, which tends to help with quicker iteration when developing packages so you can fully test the integration between it and other repositories before it goes live.
    - As of now, it supports both the `"npm"` and `"pnpm"` package managers.
    - It can swap out either `dependencies` or `devDependencies`, so we always ensure it saves to the right dependency group.
    - You use it by configuring a `.alex-c-line.private.config.js` file, which may look something like this:

```javascript
import { defineAlexCLinePrivateConfig } from "alex-c-line/configs";

export default defineAlexCLinePrivateConfig({
  useLocalPackage: {
    localPackages: {
      "alex-c-line": {
        packageManager: "pnpm",
        path: "/Users/alexman/repositories/alex-c-line",
      },
      "@alextheman/utility": {
        packageManager: "pnpm",
        path: "/Users/alexman/repositories/utility",
      },
      "@alextheman/eslint-plugin": {
        packageManager: "pnpm",
        path: "../eslint-plugin",
        dependencyGroup: "devDependencies",
      },
    },
  },
});
```

- The path to the local repository may either be absolute, or relative to the repository root.
- To get the local package, it runs the following steps:
    1. Build the package in the package repository
    2. Remove any existing `.tgz` files
    3. Run `pnpm pack` or `npm pack` to create a new `.tgz` file
    4. Install that into the consuming project.
- Bear in mind that for now, at least, if you try to undo the effects of this by using `--reverse` (that is, go from the local version back to the live version), it will default to using the latest version. This will be changed in a future release so that it caches the previous version and reads that in, but it has not been implemented just yet.
- As for `alex-c-line` itself, in case you want to use this with this package as well, it doesn't uninstall and install because really this is a CLI so the real test is what happens when you run it. Also, `alex-c-line` being able to uninstall itself would be... not a great move!
- Fortunately, the alternative approach for this special case is not too bad, and actually quite elegant!
    - We still have to build `alex-c-line` (no need to pack to `.tgz`)
    - But now instead of uninstalling and re-installing, we just execute the `dist/index.js` file that exists in the local repository!
    - Just note that we would need to forward terminal arguments to `alex-c-line` after `--` (so we would call `alex-c-line use-local-package alex-c-line -- increment-version major --no-prefix`)

## Additional Notes

- I think this might be one of the standout features of `alex-c-line` once we polish it up a bit more.
- It solves quite a big problem that I've consistently been trying to solve across both my personal work and my professional work - how do we effectively test the integration between packages locally before publishing them?
- The initial solution was to always install the repository root (that is `npm install ../utility` or `pnpm install ../utility`). This doesn't quite work 100% of the time because NPM often doesn't properly resolve all peer dependencies if you do it that way, which is VERY noticeable in React apps because you'll notice the theming of the app starts to break if you rely a lot on, say, a peer dependency of Material UI to do the theming.
- As such, I do still think the most effective way to install a local package to our repositories is to first create a `.tgz` file, then install that. It's incredibly effective given the `.tgz` is exactly what actually makes it into production, and so when you install that, all the peer dependencies are genuinely properly resolved as they should be, and you're now experiencing the closest possible parallel to what it feels like to run the package in production, but you're doing it locally.
- That said, I may include a future config option that allows you to specify the resolution method (e.g. install from `file:../package/package.tgz`, or install from just `file../package`, or some other format I have not used yet?).
Also, of course, as mentioned earlier, I will also add version caching in a future update.

